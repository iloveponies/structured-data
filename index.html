<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Structured data</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="css/base.css">
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
  <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
  <script src="js/exercise-list.js"></script>
  <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
</head>
<body>
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <ul class="nav navbar-nav">
      <li>
        <a href="index.html">← index</a>
      </li>
      <li>
        <button type="button"
                class="btn btn-default navbar-btn"
                data-toggle="collapse" data-target="#exercise-list">
          Exercises
        </button>
      </li>
      <li>
        <ul id="exercise-list" class="collapse navbar-text list-inline">
        </ul>
      </li>
  </div>
</nav>
<div class="container">
  <div class="main-content">
<header>
<h1 class="title">Structured data</h1>
</header>
<section class="alert alert-info"><h3>
Hint
</h3>
<p>The following web pages are good references to Clojure builtins and data structures:</p>
<ul>
<li><a href="http://clojuredocs.org">ClojureDocs</a></li>
<li><a href="http://clojure.org/cheatsheet">Clojure cheatsheet</a>
</section>
</li>
</ul>
<section id="fork-this" class="level2">
<h2>Fork this</h2>
<p><a href="https://github.com/iloveponies/structured-data">https://github.com/iloveponies/structured-data</a></p>
<p><a href="basic-tools.html#how-to-submit-answers-to-exercises">Here</a> are the instructions if you need them. Be sure to fork the repository behind the link above.</p>
</section>
<section id="let-there-be-names" class="level2">
<h2>Let there be names</h2>
<p>We often want to give a piece of data name, either because the act of naming gives clarity to the code, or because we want to refer to the data many times. As we have seen, namespace global names are declared with <code>def</code>. A function or value that is needed only inside one function can be given a <em>local name</em> with <code>let</code>.</p>
<p>As an example, let’s define a function for calculating the length of a triangle’s hypotenuse, given the length of its two legs:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> hypotenuse </span>[x y]
  (<span class="kw">let</span> [xx (<span class="kw">*</span> x x)
        yy (<span class="kw">*</span> y y)]
    (Math/sqrt (<span class="kw">+</span> xx yy))))</code></pre>
<p>Here we give the expressions <code>(* x x)</code> and <code>(* y y)</code> the local names <code>xx</code> and <code>yy</code>, respectively. They are visible only inside <code>hypotenuse</code>.</p>
<p><code>let</code> introduces one or more names and a scope for them:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [name1 value1
      name2 value2
      ...]
  (expression1)
  (expression2)
  ...)</code></pre>
<p>The names introduced by <code>let</code> are visible in all the expressions after them, under <code>let</code>. A name is not visible to code outside the body of the <code>let</code> it is defined in.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">user=&gt; (<span class="kw">let</span> [x <span class="dv">42</span>]
         (<span class="kw">+</span> x x))
<span class="co">;=&gt; 84</span>
user=&gt; x
CompilerException java.lang.RuntimeException:
Unable to <span class="kw">resolve</span> symbol: x in this context, compiling:(NO_SOURCE_PATH<span class="kw">:0</span>) </code></pre>
<p>Note the indentation in <code>let</code>: the names inside the brackets are all aligned together, and the expressions are indented with two spaces.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [x <span class="dv">42</span>]
  (indented x))</code></pre>
<section class="alert alert-success"><h3>
Exercise 1
</h3>
<p>The following function does a thing:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> do-a-thing </span>[x]
  (Math/pow (<span class="kw">+</span> x x) (<span class="kw">+</span> x x)))</code></pre>
Change the function <code>do-a-thing</code> so that it uses <code>let</code> to give a name to the common expression <code>(+ x x)</code> in its body.
</section>

<p>The names declared in a <code>let</code> expression can refer to previous names in the same expression:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [a <span class="dv">10</span>
      b (<span class="kw">+</span> a <span class="dv">8</span>)]
  (<span class="kw">+</span> a b))
<span class="co">;=&gt; 28</span></code></pre>
<p>In the example above, <code>b</code> can refer to <code>a</code> because <code>a</code> is declared before it. On the other hand, <code>a</code> can not refer to b:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [a (<span class="kw">+</span> b <span class="dv">42</span>)
      b <span class="dv">8</span>]
  (<span class="kw">+</span> a b))
<span class="co">; CompilerException java.lang.RuntimeException: Unable to resolve symbol:</span>
<span class="co">; b in this context, compiling:(NO_SOURCE_PATH:1)</span></code></pre>
</section>
<section id="simple-values" class="level2">
<h2>Simple values</h2>
<p>Now that we know how to give names to values, let’s look at what kind of values Clojure supports.</p>
<p>Scalar values are the regular, singular simple values like <code>42</code>, <code>&quot;foo&quot;</code> or <code>true</code>. The following table describes some of them.</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 26%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Examples</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Numbers</td>
<td style="text-align: left;"><code>42</code>, <code>3/2</code>, <code>2.1</code></td>
<td style="text-align: left;">Numbers include integers, fractions, and floats.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Strings</td>
<td style="text-align: left;"><code>&quot;foo&quot;</code></td>
<td style="text-align: left;">Text values.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Characters</td>
<td style="text-align: left;"><code>\x</code>, <code>\y</code>, <code>\√</code></td>
<td style="text-align: left;">A single characer is written with a preceding <code>\</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Keywords</td>
<td style="text-align: left;"><code>:foo</code>, <code>:?</code></td>
<td style="text-align: left;">Values often used as map keys.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Booleans</td>
<td style="text-align: left;"><code>true</code>, <code>false</code></td>
<td style="text-align: left;">Boolean values.</td>
</tr>
</tbody>
</table>
</section>
<section id="vectors" class="level2">
<h2>Vectors</h2>
<p>Collections are the other kind of values, in addition to scalars, that are crucial to programming. Clojure has support for a rich set of collection data structures. We’ll go over the most important structures in this chapter.</p>
<p>A <em>vector</em> is a collection that can be indexed with integers, like an array in other languages. It can contain values of different types.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">[<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]                 <span class="co">;=&gt; [1 2 3]</span>
[<span class="kw">:foo</span> <span class="dv">42</span> <span class="st">&quot;bar&quot;</span> (<span class="kw">+</span> <span class="dv">2</span> <span class="dv">3</span>)] <span class="co">;=&gt; [:foo 42 &quot;bar&quot; 5]</span></code></pre>
<p>A vector is written with surrounding brackets, <code>[]</code>, and the elements are written inside, separated by whitespace and optionally commas (<code>,</code>).</p>
<p>Vectors are indexed with the <code>get</code> function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">get</span> [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;c&quot;</span>] <span class="dv">1</span>)  <span class="co">;=&gt; &quot;b&quot;</span>
(<span class="kw">get</span> [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;c&quot;</span>] <span class="dv">15</span>) <span class="co">;=&gt; nil</span>
(<span class="kw">get</span> [<span class="st">&quot;x&quot;</span>] <span class="dv">0</span>)          <span class="co">;=&gt; &quot;x&quot;</span></code></pre>
<p>Trying to index a vector beyond its size does <em>not</em> throw an exception. The special value <code>nil</code> is returned, instead.</p>
<section class="alert alert-success"><h3>
Exercise 2
</h3>
<p>Write the function <code>(spiff v)</code> that takes a vector and returns the sum of the first and third elements of the vector. What happens when you pass in a vector that is too short?</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(spiff [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])       <span class="co">;=&gt; 4</span>
(spiff [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>]) <span class="co">;=&gt; 4</span>
(spiff [<span class="dv">1</span> <span class="dv">2</span>])         <span class="co">;=&gt; ?</span>
(spiff [])            <span class="co">;=&gt; ?</span></code></pre>
</section>

<section id="basic-vector-operations" class="level3">
<h3>Basic vector operations</h3>
<p>Vectors are immutable: once you have a vector, <em>you can not change it</em>. You can, however, easily create new vectors based on a vector:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">conj</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] <span class="dv">4</span>)          <span class="co">;=&gt; [1 2 3 4]</span>
(<span class="kw">assoc</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>] <span class="dv">2</span> <span class="st">&quot;foo&quot;</span>) <span class="co">;=&gt; [1 2 &quot;foo&quot; 4]</span></code></pre>
<p><code>conj</code> adds a value to a collection. Its behaviour depends on the type of collection: with vectors, it adds the value to the end of the vector. To be exact, <code>conj</code> does <em>not</em> change the given vector. Instead, it returns a new vector, based on the given vector, with the new element appended to the end.</p>
<section class="alert alert-success"><h3>
Exercise 3
</h3>
<p>Write the function <code>(cutify v)</code> that takes a vector as a parameter and adds <code>&quot;&lt;3&quot;</code> to its end.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(cutify []) =&gt; [<span class="st">&quot;&lt;3&quot;</span>]
(cutify [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) =&gt; [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="st">&quot;&lt;3&quot;</span>]
(cutify [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span>]) =&gt; [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;&lt;3&quot;</span>]</code></pre>
<!-- "> -->
</section>

</section>
<section id="vectors-a-postmodern-deconstruction" class="level3">
<h3>Vectors: A Postmodern Deconstruction</h3>
<p>Another way of extracting values from a vector is by <em>destructuring</em> it:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [[x y z] [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>]]
  (<span class="kw">str</span> x y z))
<span class="co">;=&gt; &quot;123&quot;</span></code></pre>
<p>Here, instead of giving a name to the vector <code>[1 2 3 4 5 6]</code>, we indicate with the brackets in <code>[x y z]</code> that we want to destructure the vector instead. Inside the brackets, we give names to the first three elements of the vector. <code>x</code> will be given the value of the first element, <code>1</code>; <code>b</code> will be <code>2</code> and <code>c</code> will be <code>3</code>. The concatenation of these values that <code>str</code> returns is <code>&quot;123&quot;</code>.</p>
<section class="alert alert-success"><h3>
Exercise 4
</h3>
Rewrite our earlier function <code>spiff</code> by destructuring its parameter. Call this new function <code>spiff-destructuring</code>.
</section>

<p>You can destructure function parameters directly. For an example, take the following function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> sum-pairs </span>[first-pair second-pair]
  [(<span class="kw">+</span> (<span class="kw">first</span>  first-pair) (<span class="kw">first</span>  second-pair))
   (<span class="kw">+</span> (<span class="kw">second</span> first-pair) (<span class="kw">second</span> second-pair))])</code></pre>
<p>The function takes two vectors and sums the elements pairwise:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(sum-pairs [<span class="dv">42</span> <span class="dv">5</span>]   [-<span class="dv">42</span> -<span class="dv">5</span>])   <span class="co">;=&gt; [0 0]</span>
(sum-pairs [<span class="dv">64</span> <span class="dv">256</span>] [-<span class="dv">51</span> -<span class="dv">219</span>]) <span class="co">;=&gt; [13 37]</span></code></pre>
<p><code>sum-pair</code> is not very pretty to look at. We can spiff it up by taking out the elements of its parameter vectors by destructuring them:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> sum-pairs </span>[[x1 y1] [x2 y2]]
  [(<span class="kw">+</span> x1 x2) (<span class="kw">+</span> y1 y2)])</code></pre>
<p><code>sum-pairs</code> still takes two parameter vectors, but now it does not give names to its parameters. Instead, it gives names to their first two elements by destructuring the parameters. We could have also destructured the parameters with a <code>let</code>.</p>
</section>
</section>
<section id="thinking-with-boxes" class="level2">
<h2>Thinking With Boxes</h2>
<p>Let’s define a simple representation for a two-dimensional point. It will simply be a pair (2-element vector) of two numbers.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> point </span>[x y]
  [x y])</code></pre>
<p>And a representation for a rectangle. This will simply be a pair of points, the first being the bottom left corner and the second being the top left corner.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> rectangle </span>[bottom-left top-right]
  [bottom-left top-right])</code></pre>
<p>When you have nested structures where you know their structure in advance, you can destructure multiple levels at a time.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [[[x1 y1] [x2 y2]] rectangle]
  ... <span class="kw">do</span> stuff with coordinates)</code></pre>
<p>This should prove to be useful in the following exercises.</p>
<section class="alert alert-success"><h3>
Exercise 5
</h3>
<p>Write the functions <code>(height rectangle)</code> and <code>(width rectangle)</code> that return the height and width of the given rectangle. Use destructuring.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(height (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">5</span> <span class="dv">1</span>])) =&gt; <span class="dv">0</span>
(height (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">5</span> <span class="dv">5</span>])) =&gt; <span class="dv">4</span>
(height (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">3</span>])) =&gt; <span class="dv">3</span>

(width (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">5</span> <span class="dv">1</span>]))  =&gt; <span class="dv">4</span>
(width (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">1</span> <span class="dv">1</span>]))  =&gt; <span class="dv">0</span>
(width (rectangle [<span class="dv">3</span> <span class="dv">1</span>] [<span class="dv">10</span> <span class="dv">4</span>])) =&gt; <span class="dv">7</span></code></pre>
</section>

<section class="alert alert-success"><h3>
Exercise 6
</h3>
<p>Write the function <code>(square? rectangle)</code> that returns <code>true</code> if <code>rectangle</code> is a square and otherwise <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(square? (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">2</span> <span class="dv">2</span>])) <span class="co">;=&gt; true</span>
(square? (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">2</span> <span class="dv">3</span>])) <span class="co">;=&gt; false</span>
(square? (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">1</span> <span class="dv">1</span>])) <span class="co">;=&gt; true</span>
(square? (rectangle [<span class="dv">3</span> <span class="dv">2</span>] [<span class="dv">1</span> <span class="dv">0</span>])) <span class="co">;=&gt; true</span>
(square? (rectangle [<span class="dv">3</span> <span class="dv">2</span>] [<span class="dv">1</span> <span class="dv">1</span>])) <span class="co">;=&gt; false</span></code></pre>
</section>

<section class="alert alert-success"><h3>
Exercise 7
</h3>
<p>Write the function <code>(area rectangle)</code> that returns the area of the given rectangle.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(area (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">5</span> <span class="dv">1</span>]))  =&gt; <span class="dv">0</span>
(area (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">1</span> <span class="dv">1</span>]))  =&gt; <span class="dv">1</span>
(area (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">4</span> <span class="dv">3</span>]))  =&gt; <span class="dv">12</span>
(area (rectangle [<span class="dv">3</span> <span class="dv">1</span>] [<span class="dv">10</span> <span class="dv">4</span>])) =&gt; <span class="dv">21</span></code></pre>
</section>

<section class="alert alert-success"><h3>
Exercise 8
</h3>
<p>Write the function <code>(contains-point? rectangle point)</code> that returns <code>true</code> if <code>rectangle</code> contains <code>point</code> and otherwise <code>false</code>.</p>
<p>Remember that you can give <code>&lt;=</code> multiple parameters. <code>(&lt;= x y z)</code> returns <code>true</code> if <span class="math">\(x \leq y \leq z\)</span> holds. Otherwise <code>false</code>.</p>
<!-- >> -->

<p>Hint: <code>and</code> is useful.</p>
<p>use destructuring.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(contains-point? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">2</span>])
                 (point <span class="dv">1</span> <span class="dv">1</span>))            <span class="co">;=&gt; true</span>
(contains-point? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">2</span>])
                 (point <span class="dv">2</span> <span class="dv">1</span>))            <span class="co">;=&gt; true</span>
(contains-point? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">2</span>])
                 (point -<span class="dv">3</span> <span class="dv">1</span>))           <span class="co">;=&gt; false</span>
(contains-point? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">2</span>])
                 (point <span class="dv">1</span> <span class="dv">3</span>))            <span class="co">;=&gt; false</span>
(contains-point? (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">2</span> <span class="dv">2</span>])
                 (point <span class="dv">1</span> <span class="dv">1</span>))            <span class="co">;=&gt; true</span>
(contains-point? (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">1</span> <span class="dv">1</span>])
                 (point <span class="dv">1</span> <span class="dv">1</span>))            <span class="co">;=&gt; true</span></code></pre>
</section>

<section class="alert alert-success"><h3>
Exercise 9
</h3>
<p>Write the function <code>(contains-rectangle? outer inner)</code> that returns <code>true</code> if the rectangle <code>inner</code> is inside the rectangle <code>outer</code> and otherwise <code>false</code>.</p>
<p>Hint: use <code>contains-point?</code></p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(contains-rectangle? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">3</span> <span class="dv">3</span>])
                     (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">2</span> <span class="dv">2</span>])) <span class="co">;=&gt; true</span>
(contains-rectangle? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">2</span>])
                     (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">3</span> <span class="dv">3</span>])) <span class="co">;=&gt; false</span>
(contains-rectangle? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">1</span> <span class="dv">1</span>])
                     (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">1</span> <span class="dv">1</span>])) <span class="co">;=&gt; true</span>
(contains-rectangle? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">1</span> <span class="dv">1</span>])
                     (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">2</span> <span class="dv">2</span>])) <span class="co">;=&gt; false</span></code></pre>
</section>

</section>
<section id="maps" class="level2">
<h2>Maps</h2>
<p>Where a vector associates integers to values, a <em>map</em> is not restricted to integer keys. You can use any kind of value as a key. A map is written with curly brackets, <code>{}</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">{<span class="st">&quot;foo&quot;</span> <span class="dv">42</span>, <span class="st">&quot;bar&quot;</span> <span class="dv">666</span>}
{<span class="st">&quot;mehmeh&quot;</span> (<span class="kw">+</span> <span class="dv">2</span> <span class="dv">5</span>)
 <span class="st">&quot;rupatipor&quot;</span> <span class="st">&quot;ropopo&quot;</span>}</code></pre>
<p>A map is indexed with the <code>get</code> function:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [ages {<span class="st">&quot;Juhana&quot;</span> <span class="dv">3</span>
            <span class="st">&quot;Ilmari&quot;</span> <span class="dv">42</span>
            <span class="st">&quot;King of All Cosmos&quot;</span> -<span class="dv">6</span>}]
  (<span class="kw">get</span> ages <span class="st">&quot;King of All Cosmos&quot;</span>))
<span class="co">;=&gt; -6</span></code></pre>
<p>In idiomatic Clojure programs, the keys of a map are often <em>keywords</em>. Keywords are a convenient way of naming keys for values in associative collections such as maps. They are written with a preceding <code>:</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> book </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span>
           <span class="kw">:authors</span> [{<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>}]})

(<span class="kw">get</span> book <span class="kw">:title</span>) <span class="co">;=&gt; &quot;The City and the City&quot;</span></code></pre>
<p>Keywords are even more convenient than this. They work as functions that access collections:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">:title</span> book) <span class="co">;=&gt; &quot;The City and the City&quot;</span></code></pre>
<p>When used as a function and given a collection, a keyword looks itself up in the collection and returns the value associated with it.</p>
<section id="we-are-a-legion" class="level3">
<h3>We are a legion</h3>
<p><code>count</code> can be used to find out the amount of elements in a collection.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">count</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; 3</span>
(<span class="kw">count</span> {<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>}) =&gt; <span class="dv">2</span>
(<span class="kw">count</span> <span class="st">&quot;:)&quot;</span>) =&gt; <span class="dv">2</span></code></pre>
<p>As we can see, <code>count</code> tells the amount of keys for a map and the amount of elements for a vector. It can also be used to find out the length of a string.</p>
<p>Let’s define some authors and a couple of books with maps and vectors.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> china </span>{<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>})
(<span class="kw">def</span><span class="fu"> octavia </span>{<span class="kw">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span>
              <span class="kw">:birth-year</span> <span class="dv">1947</span>
              <span class="kw">:death-year</span> <span class="dv">2006</span>})
(<span class="kw">def</span><span class="fu"> friedman </span>{<span class="kw">:name</span> <span class="st">&quot;Daniel Friedman&quot;</span> <span class="kw">:birth-year</span> <span class="dv">1944</span>})
(<span class="kw">def</span><span class="fu"> felleisen </span>{<span class="kw">:name</span> <span class="st">&quot;Matthias Felleisen&quot;</span>})

(<span class="kw">def</span><span class="fu"> cities </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span> <span class="kw">:authors</span> [china]})
(<span class="kw">def</span><span class="fu"> wild-seed </span>{<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>, <span class="kw">:authors</span> [octavia]})
(<span class="kw">def</span><span class="fu"> embassytown </span>{<span class="kw">:title</span> <span class="st">&quot;Embassytown&quot;</span>, <span class="kw">:authors</span> [china]})
(<span class="kw">def</span><span class="fu"> little-schemer </span>{<span class="kw">:title</span> <span class="st">&quot;The Little Schemer&quot;</span>
                     <span class="kw">:authors</span> [friedman, felleisen]})</code></pre>
<section class="alert alert-success"><h3>
Exercise 10
</h3>
<p>Write the function <code>(title-length book)</code> that counts the length of the book’s title.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(title-length cities)         <span class="co">;=&gt; 21</span>
(title-length wild-seed)      <span class="co">;=&gt; 9</span>
(title-length little-schemer) <span class="co">;=&gt; 18</span></code></pre>
</section>

<section class="alert alert-success"><h3>
Exercise 11
</h3>
<p>Write the function <code>(author-count book)</code> that returns the amount of authors that <code>book</code> has.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(author-count cities)         <span class="co">;=&gt; 1</span>
(author-count wild-seed)      <span class="co">;=&gt; 1</span>
(author-count little-schemer) <span class="co">;=&gt; 2</span></code></pre>
</section>

<section class="alert alert-success"><h3>
Exercise 12
</h3>
<p>Write the function <code>(multiple-authors? book)</code> that returns <code>true</code> if <code>book</code> has multiple authors, otherwise <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(multiple-authors? cities)         <span class="co">;=&gt; false</span>
(multiple-authors? wild-seed)      <span class="co">;=&gt; false</span>
(multiple-authors? little-schemer) <span class="co">;=&gt; true</span></code></pre>
</section>

</section>
<section id="adding-values-to-a-map" class="level3">
<h3>Adding Values to a Map</h3>
<p><code>(assoc a-map a-key a-value)</code> sets the value of <code>a-key</code> in <code>a-map</code> to be <code>a-value</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">assoc</span> {<span class="kw">:a</span> <span class="dv">1</span>} <span class="kw">:b</span> <span class="dv">2</span>) <span class="co">;=&gt; {:b 2, :a 1}</span>
(<span class="kw">assoc</span> {<span class="kw">:a</span> <span class="dv">1</span>} <span class="kw">:a</span> <span class="dv">2</span>) <span class="co">;=&gt; {:a 2}</span></code></pre>
<p>Let’s add some information to a book:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">assoc</span> cities <span class="kw">:awards</span> [<span class="st">&quot;Hugo&quot;</span>, <span class="st">&quot;World Fantasy Award&quot;</span>,
                       <span class="st">&quot;Arthur C. Clarke Award&quot;</span>,
                       <span class="st">&quot;British Science Fiction Award&quot;</span>])
<span class="co">;=&gt; {:awards [&quot;Hugo&quot; &quot;World Fantasy Award&quot; &quot;Arthur C. Clarke Award&quot;</span>
<span class="co">;             &quot;British Science Fiction Award&quot;]</span>
<span class="co">;    :title &quot;The City and the City&quot;</span>
<span class="co">;    :authors [{:birth-year 1972, :name &quot;China Miéville&quot;}]}</span></code></pre>
<p>Vectors are an associative data structure, so <code>assoc</code> also works with them.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure"><span class="co">;index: 0 1 2                0   1   2</span>
(<span class="kw">assoc</span> [<span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>] <span class="dv">1</span> <span class="st">&quot;~o~&quot;</span>) <span class="co">;=&gt; [3 &quot;~o~&quot; 1]</span></code></pre>
<p>Here the key that you give as a parameter is the index that you want to change.</p>
<p>Assoc does not actually change the original data structure, but instead returns an updated version of it.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [original [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]
      new      (<span class="kw">assoc</span> original <span class="dv">2</span> <span class="st">&quot;foo&quot;</span>)]
  original)
<span class="co">;=&gt; [1 2 3 4]</span></code></pre>
<section class="alert alert-success"><h3>
Exercise 13
</h3>
<p>Use <code>assoc</code> and <code>conj</code> to write the function <code>(add-author book new-author)</code> that takes a book and an author as a parameter and adds <code>author</code> to <code>book</code>s authors.</p>
<p>Hint: use <code>let</code> to avoid pain</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(add-author little-schemer {<span class="kw">:name</span> <span class="st">&quot;Gerald J. Sussman&quot;</span>})
<span class="co">;=&gt; {:title &quot;The Little Schemer&quot;</span>
<span class="co">;    :authors [{:birth-year 1944, :name &quot;Daniel Friedman&quot;}</span>
<span class="co">;              {:name &quot;Matthias Felleisen&quot;}</span>
<span class="co">;              {:name &quot;Gerald J. Sussman&quot;}]}</span>
(add-author {<span class="kw">:authors</span> [{<span class="kw">:name</span> <span class="st">&quot;Juhana&quot;</span>}]} {<span class="kw">:name</span> <span class="st">&quot;Jani&quot;</span>})
<span class="co">;=&gt; {:authors [{:name &quot;Juhana&quot;} {:name &quot;Jani&quot;}]}</span></code></pre>
</section>

<p>The keys and values of a map can be of any data type, and one map can contain any number of different data types as both keys and values.</p>
<p><code>(contains? a-map a-key)</code> can be used to check if <code>a-map</code> has a value for <code>a-key</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">contains?</span> {<span class="st">&quot;a&quot;</span> <span class="dv">1</span>} <span class="st">&quot;a&quot;</span>)   <span class="co">;=&gt; true</span>
(<span class="kw">contains?</span> {<span class="st">&quot;a&quot;</span> <span class="dv">1</span>} <span class="dv">1</span>)     <span class="co">;=&gt; false</span>
(<span class="kw">contains?</span> {<span class="st">&quot;a&quot;</span> nil} <span class="st">&quot;a&quot;</span>) <span class="co">;=&gt; true</span>
(<span class="kw">contains?</span> cities <span class="kw">:title</span>) <span class="co">;=&gt; true</span>
(<span class="kw">contains?</span> cities <span class="kw">:name</span>)  <span class="co">;=&gt; false</span></code></pre>
<section class="alert alert-success"><h3>
Exercise 14
</h3>
<p>Write the function <code>(alive? author)</code> which takes an author map and returns <code>true</code> if the <code>author</code> is alive, otherwise <code>false</code>.</p>
<p>An author is alive if the author does not have a death year.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(alive? china)   <span class="co">;=&gt; true</span>
(alive? octavia) <span class="co">;=&gt; false</span></code></pre>
</section>

</section>
</section>
<section id="serial-grave-digging" class="level2">
<h2>Serial grave digging</h2>
<p>We know how to extract information from a single book or author. However, we often want to extract information from a collection of items. As an example, given a collection of books, we want the names of all the authors:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown, little-schemer])

(all-author-names books)
<span class="co">;=&gt; #{&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;</span>
<span class="co">;     &quot;Daniel Friedman&quot; &quot;Matthias Felleisen&quot;}</span></code></pre>
<p>How should we implement <code>all-author-names</code>?</p>
<p>We’ll give the implementation now, and introduce the new concepts used one by one. The implementation looks like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> author-names </span>[book]
  (<span class="kw">map</span> <span class="kw">:name</span> (<span class="kw">:authors</span> book)))

(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
    (<span class="kw">set</span> (<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-names books))))</code></pre>
<p>Now there’s a lot of new stuff there, so we’ll take a detour to learn it all before continuing with our book library.</p>
<p>Let’s take a look at this <code>map</code> function.</p>
<section id="sequences" class="level3">
<h3>Sequences</h3>
<p>Before talking about <code>map</code>, we need to introduce a new concept: the <em>sequence</em>. Many of Clojure’s functions that operate on vectors and other collections actually operate on sequences. The <code>(seq collection)</code> function returns a sequence constructed from a collection, such as a vector or a map.</p>
<p>Sequences have the following operations:</p>
<ul>
<li><p><code>(first sequence)</code> returns the first element of the sequence.</p></li>
<li><p><code>(rest sequence)</code> returns the sequence without its first element.</p></li>
<li><p><code>(cons item sequence)</code> returns a new sequence where <code>item</code> is the first element and <code>sequence</code> is the rest.</p></li>
</ul>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])          <span class="co">;=&gt; (1 2 3)</span>
(<span class="kw">seq</span> {<span class="kw">:a</span> <span class="dv">42</span> <span class="kw">:b</span> <span class="st">&quot;foo&quot;</span> <span class="kw">:c</span> [<span class="st">&quot;ur&quot;</span> <span class="st">&quot;dad&quot;</span>]})
                       <span class="co">;=&gt; ([:a 42] [:c [&quot;ur&quot; &quot;dad&quot;]] [:b &quot;foo&quot;])</span>
(<span class="kw">first</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]))  <span class="co">;=&gt; 1</span>
(<span class="kw">rest</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))    <span class="co">;=&gt; (2 3)</span>
(<span class="kw">cons</span> <span class="dv">0</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])) <span class="co">;=&gt; (0 1 2 3)</span></code></pre>
<p>Here you can see the printed form of sequences, the elements inside <code>(</code> and <code>)</code>. This has the consequence that copying <code>(1 2 3)</code> back to the REPL tries to call <code>1</code> as a function. The result is that you can not use the printed form of a sequence as a value like you could with vectors and maps.</p>
<p>Actually, the sequence functions call <code>seq</code> on their collection parameters themselves, so we can just write the above examples like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">first</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])  <span class="co">;=&gt; 1</span>
(<span class="kw">rest</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])   <span class="co">;=&gt; (2 3)</span>
(<span class="kw">cons</span> <span class="dv">0</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; (0 1 2 3)</span></code></pre>
</section>
<section id="the-map-function" class="level3">
<h3>The map function</h3>
<p><code>(map function collection)</code> takes two parameters, a function and a sequenceable collection. It calls the function on each element of the sequence and returns a sequence of the return values.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> munge </span>[x]
  (<span class="kw">+</span> x <span class="dv">42</span>))

(<span class="kw">map</span> munge [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])
<span class="co">;=&gt; ((munge 1) (munge 2) (munge 3) (munge 4)) ; [note below]</span>
<span class="co">;=&gt; ( 43        44        45        46)</span></code></pre>
<p><em>Note:</em> You can’t paste the result line (or the middle one) to the REPL, as it is the printed form of a sequence.</p>
<section class="alert alert-success"><h3>
Exercise 15
</h3>
<p>Write the function <code>(element-lengths collection)</code> that returns the lengths of every item in <code>collection</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(element-lengths [<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;&quot;</span> <span class="st">&quot;quux&quot;</span>])  <span class="co">;=&gt; (3 3 0 4)</span>
(element-lengths [<span class="st">&quot;x&quot;</span> [<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>] {<span class="kw">:y</span> <span class="dv">42</span>}]) <span class="co">;=&gt; (1 3 1)</span></code></pre>
</section>

<p>Earlier, we briefly introduces the <code>fn</code> special form that can be used to create functions. This is useful when you want a function that is only visible in the definition of another function. Quite often you want to use <code>let</code> to give name to this helper function.</p>
<p>Let’s rewrite the example above in this style:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> mungefy </span>[a-seq]
  (<span class="kw">let</span> [munge (<span class="kw">fn</span> [x] (<span class="kw">+</span> x <span class="dv">42</span>))]
    (<span class="kw">map</span> munge a-seq)))</code></pre>
<p>Now the function <code>munge</code> is only visible inside the definition of <code>mungefy</code>. It should work like the previous one.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(mungefy [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; (43 44 45 46)</span></code></pre>
<section class="alert alert-success"><h3>
Exercise 16
</h3>
<p>Use <code>map</code> to write the function <code>(second-elements collection)</code> that takes a vector of vectors and returns a sequence of the second elements.</p>
<p>Remember that you can use <code>get</code> to index a vector.</p>
<p>Use <code>fn</code> and <code>let</code> to create a helper function and use it with <code>map</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(second-elements [[<span class="dv">1</span> <span class="dv">2</span>] [<span class="dv">2</span> <span class="dv">3</span>] [<span class="dv">3</span> <span class="dv">4</span>]]) <span class="co">;=&gt; (2 3 4)</span>
(second-elements [[<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>] [<span class="dv">1</span>] [<span class="st">&quot;a&quot;</span> <span class="st">&quot;s&quot;</span> <span class="st">&quot;d&quot;</span> <span class="st">&quot;f&quot;</span>]])
<span class="co">;=&gt; (2 nil &quot;s&quot;)</span></code></pre>
</section>

<p>When you have a sequence of maps, the fact that <code>:keywords</code> are also functions can be helpful.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">:name</span> {<span class="kw">:name</span> <span class="st">&quot;MEEEE&quot;</span>, <span class="kw">:secret</span> <span class="st">&quot;Awesome&quot;</span>}) <span class="co">;=&gt;  &quot;MEEEE&quot;</span></code></pre>
<p>You can therefore use a <code>:keyword</code> as the function parameter of <code>map</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">let</span> [people [{<span class="kw">:name</span> <span class="st">&quot;Juhana&quot;</span>, <span class="kw">:age</span> <span class="dv">3</span>}
              {<span class="kw">:name</span> <span class="st">&quot;Ilmari&quot;</span>, <span class="kw">:age</span> <span class="dv">42</span>}
              {<span class="kw">:name</span> <span class="st">&quot;Jani&quot;</span>, <span class="kw">:age</span> <span class="dv">72</span>}
              {<span class="kw">:name</span> <span class="st">&quot;King of All Cosmos&quot;</span> <span class="kw">:age</span> -<span class="dv">6</span>}]]
  (<span class="kw">map</span> <span class="kw">:age</span> people))
<span class="co">;=&gt; (3 42 72 -6)</span></code></pre>
<section class="alert alert-success"><h3>
Exercise 17
</h3>
<p>Write the function <code>(titles books)</code> that takes a collection of books and returns their titles.</p>
<p>Using our earlier examples:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> china </span>{<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>})
(<span class="kw">def</span><span class="fu"> octavia </span>{<span class="kw">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span>
              <span class="kw">:birth-year</span> <span class="dv">1947</span>
              <span class="kw">:death-year</span> <span class="dv">2006</span>})
(<span class="kw">def</span><span class="fu"> friedman </span>{<span class="kw">:name</span> <span class="st">&quot;Daniel Friedman&quot;</span> <span class="kw">:birth-year</span> <span class="dv">1944</span>})
(<span class="kw">def</span><span class="fu"> felleisen </span>{<span class="kw">:name</span> <span class="st">&quot;Matthias Felleisen&quot;</span>})

(<span class="kw">def</span><span class="fu"> cities </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span> <span class="kw">:authors</span> [china]})
(<span class="kw">def</span><span class="fu"> wild-seed </span>{<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>, <span class="kw">:authors</span> [octavia]})
(<span class="kw">def</span><span class="fu"> embassytown </span>{<span class="kw">:title</span> <span class="st">&quot;Embassytown&quot;</span>, <span class="kw">:authors</span> [china]})
(<span class="kw">def</span><span class="fu"> little-schemer </span>{<span class="kw">:title</span> <span class="st">&quot;The Little Schemer&quot;</span>
                     <span class="kw">:authors</span> [friedman, felleisen]})

(<span class="kw">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown, little-schemer])</code></pre>
<p><code>titles</code> should work like this:</p>
<pre><code>(titles [cities]) ;=&gt; (&quot;The City and the City&quot; )
(titles books)
;=&gt; (&quot;The City and the City&quot; &quot;Wild Seed&quot;
;    &quot;Embassytown&quot; &quot;The Little Schemer&quot;)</code></pre>
</section>

<p>Okey, so now that <code>map</code> has been gone over, let’s see the definition of <code>all-author-names</code> again.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> author-names </span>[book]
  (<span class="kw">map</span> <span class="kw">:name</span> (<span class="kw">:authors</span> book)))

(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">set</span> (<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-name books))))</code></pre>
<p><code>author-names</code> returns the names of the authors of a single book.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(author-names cities)         <span class="co">;=&gt; (&quot;China Miéville&quot;)</span>
(author-names little-schemer) <span class="co">;=&gt; (&quot;Daniel Friedman&quot; &quot;Matthias Felleisen&quot;)</span></code></pre>
<p>Since this is just a helper function used inside <code>all-author-names</code> we can move it inside by using <code>let</code> and <code>fn</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-names
         (<span class="kw">fn</span> [book] (<span class="kw">map</span> <span class="kw">:name</span> (<span class="kw">:authors</span> book)))]
    (<span class="kw">set</span> (<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-names books)))))</code></pre>
<p>The definition of <code>all-author-names</code> still has some mysterious words like <code>set</code>, <code>apply</code> and <code>concat</code> in it. Let’s see what would happen without them.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">map</span> author-names [cities]) <span class="co">;=&gt; ((&quot;China Miéville&quot;))</span>
(<span class="kw">map</span> author-names [cities, wild-seed]) <span class="co">;=&gt; ((&quot;China Miéville&quot;) (&quot;Octavia E. Butler&quot;))</span></code></pre>
<p>So first of all we would get every books authors inside a sequence. To fix this, we need to concatenate the sequences. To do this, there is <code>concat</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">concat</span> [<span class="st">&quot;China Miéville&quot;</span>] [<span class="st">&quot;Octavia E. Butler&quot;</span>]) <span class="co">;=&gt; (&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;)</span></code></pre>
<p>This looks like what we want. However, if we simply try to use <code>(concat (map author-names books))</code>, we get the following problem:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">concat</span> (<span class="kw">map</span> author-names [cities, wild-seed]))
<span class="co">;=&gt; (concat ((&quot;China Miéville&quot;) (&quot;Octavia E. Butler&quot;)))</span>
<span class="co">;=&gt; ((&quot;China Miéville&quot;) (&quot;Octavia E. Butler&quot;))</span></code></pre>
<p>So we end up only giving <code>concat</code> one argument and it simply returns the argument. What we want is to give the elements of <code>(map author-names books)</code> to <code>concat</code> as arguments.</p>
<p>No worries, there is a way to do this. Let’s check out <code>apply</code>.</p>
</section>
<section id="apply-now-redux" class="level3">
<h3>Apply Now, Redux</h3>
<p><code>(apply function a-seq)</code> applies <code>function</code> to the arguments in <code>a-seq</code>. Here’s an example:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">apply</span> <span class="kw">+</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])
<span class="co">;=&gt; (+ 1 2 3)</span>
<span class="co">;=&gt; 6</span></code></pre>
<p>And here’s another with <code>concat</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">apply</span> <span class="kw">concat</span> [[<span class="st">&quot;China Miéville&quot;</span>] [<span class="st">&quot;Octavia E. Butler&quot;</span>]])
<span class="co">;=&gt; (concat [&quot;China Miéville&quot;] [&quot;Octavia E. Butler&quot;])</span>
<span class="co">;=&gt; (&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;)</span></code></pre>
<p>More generally, <code>apply</code> works like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">apply</span> function [arg1 arg2 arg3 ...]) =&gt; (function arg1 arg2 arg3 ...)</code></pre>
<section class="alert alert-success"><h3>
Exercise 18
</h3>
<p>Write the function <code>(stars n)</code> that returns a string with <code>n</code> aterisks <code>\*</code>.</p>
<p>The function <code>(repeat n x)</code> returns a sequence with <code>n</code> <code>x</code>s:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">repeat</span> <span class="dv">5</span> <span class="st">&quot;*&quot;</span>) <span class="co">;=&gt; (&quot;*&quot; &quot;*&quot; &quot;*&quot; &quot;*&quot; &quot;*&quot;)</span>
(<span class="kw">repeat</span> <span class="dv">3</span> <span class="st">&quot;~o~&quot;</span>) <span class="co">;=&gt; (&quot;~o~&quot; &quot;~o~&quot; &quot;~o~&quot;)</span></code></pre>
<p>Remember that you can use <code>str</code> to concatenate strings.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(stars <span class="dv">1</span>) <span class="co">;=&gt; &quot;*&quot;</span>
(stars <span class="dv">7</span>) <span class="co">;=&gt; &quot;*******&quot;</span>
(stars <span class="dv">3</span>) <span class="co">;=&gt; &quot;***&quot;</span></code></pre>
<!-- ********* -->
</section>

<section class="alert alert-success"><h3>
Exercise 19
</h3>
<p>Write the function <code>(monotonic? a-seq)</code> that returns <code>true</code> if <code>a-seq</code> is monotonic and otherwise <code>false</code>.</p>
<p>A sequence is monotonic if is either inceasing or decreasing. In a decreasing sequence every element is at most as large as the previous one and in an increasing sequence every member is at least as large as the previous one.</p>
<p>Use <code>apply</code>.</p>
<p>Hint: <code>&lt;=</code> might be useful</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(monotonic? [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])     <span class="co">;=&gt; true</span>
(monotonic? [<span class="dv">0</span> <span class="dv">1</span> <span class="dv">10</span> <span class="dv">11</span>]) <span class="co">;=&gt; true</span>
(monotonic? [<span class="dv">3</span> <span class="dv">2</span> <span class="dv">0</span> -<span class="dv">3</span>])  <span class="co">;=&gt; true</span>
(monotonic? [<span class="dv">3</span> <span class="dv">2</span> <span class="dv">2</span>])     <span class="co">;=&gt; true    Not strictly monotonic</span>
(monotonic? [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">1</span> <span class="dv">0</span>])   <span class="co">;=&gt; false</span></code></pre>
</section>

<p>So now we can put all authors into a single list. There’s just one problem left. What is that? Well, let’s see what happens if we put together everything seen so far.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-names books))
<span class="co">;=&gt; (&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;</span>
<span class="co">;    &quot;China Miéville&quot; &quot;Daniel Friedman&quot;</span>
<span class="co">;    &quot;Matthias Felleisen&quot;)</span></code></pre>
<p>We had two books by China Miéville, so his name is in the resulting sequence twice. But when we want to see the authors, we are usually not interested in duplicates. So lets turn the sequence into a data structure that supports this.</p>
</section>
<section id="set" class="level3">
<h3>Set</h3>
<p>Our last major data structure is the set. It is an unordered collection of items without duplicates.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">set</span> [<span class="st">&quot;^^&quot;</span> <span class="st">&quot;^^&quot;</span> <span class="st">&quot;^__*__^&quot;</span>]) <span class="co">;=&gt; #{&quot;^__*__^&quot; &quot;^^&quot;}</span>
(<span class="kw">set</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>]) <span class="co">;=&gt; #{1 2 3}</span></code></pre>
<p>The textual form of a set is <code>#{an-elem another-elem ...}</code> and you can convert another collection into a set with the function <code>set</code>.</p>
<p>Sets have three basic operations:</p>
<p>You can check whether a set contains an element with the function <code>contains?</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> games </span>#{<span class="st">&quot;Portal&quot;</span>, <span class="st">&quot;Planescape: Torment&quot;</span>,
             <span class="st">&quot;Machinarium&quot;</span>, <span class="st">&quot;Alpha Protocol&quot;</span>})

(<span class="kw">contains?</span> games <span class="st">&quot;Portal&quot;</span>) <span class="co">;=&gt; true</span>
(<span class="kw">contains?</span> games <span class="st">&quot;RAGE&quot;</span>)   <span class="co">;=&gt; false</span>
(<span class="kw">contains?</span> games <span class="dv">42</span>)       <span class="co">;=&gt; false</span></code></pre>
<p><code>(conj set elem)</code> adds elem to <code>set</code> if it does not already have <code>elem</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">conj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>} <span class="kw">:EEEEE</span>) <span class="co">;=&gt; #{:a :c :b :EEEEE}</span></code></pre>
<p>Nothing happens if <code>elem</code> is already a member of <code>set</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">conj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>} <span class="kw">:a</span>)     <span class="co">;=&gt; #{:a :c :b}</span></code></pre>
<p>You can also add multiple elements by giving <code>conj</code> additional arguments:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">conj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>} <span class="kw">:d</span> <span class="kw">:e</span>)  <span class="co">;=&gt; #{:a :c :b :d :e}</span></code></pre>
<p>Finally, <code>(disj set elem)</code> removes <code>elem</code> from <code>set</code> if it contains <code>elem</code>:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">disj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>} <span class="kw">:c</span>) <span class="co">;=&gt; #{:a :b}</span>
(<span class="kw">disj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>} <span class="kw">:EEEEE</span>) <span class="co">;=&gt; #{:a :c :b}</span>
(<span class="kw">disj</span> #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>} <span class="kw">:c</span> <span class="kw">:a</span>) <span class="co">;=&gt; #{:b}</span></code></pre>
<p><a id="toggle"></a></p>
<section class="alert alert-success"><h3>
Exercise 20
</h3>

<p>Write the function <code>(toggle a-set elem)</code> that removes <code>elem</code> from <code>a-set</code> if <code>a-set</code> contains <code>elem</code>, and adds it to the set otherwise.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(toggle #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>} <span class="kw">:d</span>) <span class="co">;=&gt; #{:a :c :b :d}</span>
(toggle #{<span class="kw">:a</span> <span class="kw">:b</span> <span class="kw">:c</span>} <span class="kw">:a</span>) <span class="co">;=&gt; #{:c :b}</span></code></pre>
</section>

<p>If you want to know the size of a set, <code>count</code> also works with sets.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">count</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>}) <span class="co">;=&gt; 3</span>
(<span class="kw">count</span> (<span class="kw">set</span> [<span class="dv">1</span> <span class="dv">2</span>])) <span class="co">;=&gt; 2</span></code></pre>
<section class="alert alert-success"><h3>
Exercise 21
</h3>
<p>Write the function <code>(contains-duplicates? sequence)</code> that takes a sequence as a parameter and returns <code>true</code> if <code>sequence</code> contains some element multiple times. Otherwise it returns <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(contains-duplicates? [<span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> -<span class="dv">40</span>]) <span class="co">;=&gt; true</span>
(contains-duplicates? [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> -<span class="dv">40</span>]) <span class="co">;=&gt; false</span>
(contains-duplicates? [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="st">&quot;a&quot;</span> <span class="st">&quot;a&quot;</span>]) <span class="co">;=&gt; true</span></code></pre>
</section>

<p>Our books looked like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> friedman </span>{<span class="kw">:name</span> <span class="st">&quot;Daniel Friedman&quot;</span> <span class="kw">:birth-year</span> <span class="dv">1944</span>})
(<span class="kw">def</span><span class="fu"> felleisen </span>{<span class="kw">:name</span> <span class="st">&quot;Matthias Felleisen&quot;</span>})

(<span class="kw">def</span><span class="fu"> little-schemer </span>{<span class="kw">:title</span> <span class="st">&quot;The Little Schemer&quot;</span>
                     <span class="kw">:authors</span> [friedman, felleisen]})</code></pre>
<p>Now we can understand the whole implementation of <code>all-author-names</code>. We use</p>
<ul>
<li><code>fn</code> to introduce a helper function,</li>
<li>keywords to index the books,</li>
<li>map to get all authors from a single book</li>
<li><code>let</code> to give a name to our helper function,</li>
<li><code>map</code> to apply the helper function to all the given books, and</li>
<li>construct a set with the <code>set</code> function to get rid of duplicates.</li>
</ul>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-names
         (<span class="kw">fn</span> [book] (<span class="kw">map</span> <span class="kw">:name</span> (<span class="kw">:authors</span> book)))]
    (<span class="kw">set</span> (<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-names books)))))</code></pre>
<p>Calling our function returns the desired set:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(all-author-names books)
<span class="co">;=&gt; #{&quot;Matthias Felleisen&quot; &quot;China Miéville&quot;</span>
<span class="co">;     &quot;Octavia E. Butler&quot; &quot;Daniel Friedman&quot;}</span></code></pre>
</section>
</section>
<section id="representing-books-take-two" class="level2">
<h2>Representing Books, Take Two</h2>
<p>Now I would like to ask whether <code>little-schemer</code> has <code>felleisen</code> as an author or not. This turns out to be problematic. There is no function on vectors that can be used to query membership. So how about we change the representation of books? We now have a motivation to put authors into a set instead of a vector. This feels like a more natural fit, since a book never has a single author multiple times and our data doesn’t give a natural order for the authors.</p>
<p>New representation:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> little-schemer </span>{<span class="kw">:title</span> <span class="st">&quot;The Little Schemer&quot;</span>
                     <span class="kw">:authors</span> #{friedman, felleisen}})</code></pre>
<section class="alert alert-success"><h3>
Exercise 22
</h3>
<p>Write the function <code>(old-book-&gt;new-book book)</code> that takes a book with the previous representation (authors in a vector) and returns the same book in the new representation (authors in a set).</p>
<p>Use <code>assoc</code> to change the representation. Do not construct a new map using the map literal syntax.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(old-book-&gt;new-book {<span class="kw">:title</span> <span class="st">&quot;The Little Schemer&quot;</span>
                     <span class="kw">:authors</span> [friedman, felleisen]})
<span class="co">;=&gt; {:title &quot;The Little Schemer&quot; :authors #{friedman, felleisen}}</span>
(old-book-&gt;new-book {<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>, <span class="kw">:authors</span> [octavia]})
<span class="co">;=&gt; {:title &quot;Wild Seed&quot;, :authors #{octavia}}</span></code></pre>
<p>The reason to use <code>assoc</code> is that it allows us to keep any additional key-value pairs intact. Earlier we had an example where we added a list of awards to a book. By using <code>assoc</code>, these additional key-value pairs do not disappear anywhere during the transformation.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(old-book-&gt;new-book
  {<span class="kw">:awards</span> [<span class="st">&quot;Hugo&quot;</span> <span class="st">&quot;World Fantasy Award&quot;</span> <span class="st">&quot;Arthur C. Clarke Award&quot;</span>
            <span class="st">&quot;British Science Fiction Award&quot;</span>]
   <span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span>
   <span class="kw">:authors</span> [{<span class="kw">:birth-year</span> <span class="dv">1972</span>, <span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>}]})
<span class="co">;=&gt; {:awards [&quot;Hugo&quot; &quot;World Fantasy Award&quot; &quot;Arthur C. Clarke Award&quot;</span>
<span class="co">;             &quot;British Science Fiction Award&quot;]</span>
<span class="co">;    :title &quot;The City and the City&quot;</span>
<span class="co">;    :authors #{{:birth-year 1972, :name &quot;China Miéville&quot;}}}</span></code></pre>
</section>

<p>Here are all of the books changed to the new representation:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> china </span>{<span class="kw">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1972</span>})
(<span class="kw">def</span><span class="fu"> octavia </span>{<span class="kw">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span>
              <span class="kw">:birth-year</span> <span class="dv">1947</span>
              <span class="kw">:death-year</span> <span class="dv">2006</span>})
(<span class="kw">def</span><span class="fu"> friedman </span>{<span class="kw">:name</span> <span class="st">&quot;Daniel Friedman&quot;</span> <span class="kw">:birth-year</span> <span class="dv">1944</span>})
(<span class="kw">def</span><span class="fu"> felleisen </span>{<span class="kw">:name</span> <span class="st">&quot;Matthias Felleisen&quot;</span>})

(<span class="kw">def</span><span class="fu"> cities </span>{<span class="kw">:title</span> <span class="st">&quot;The City and the City&quot;</span> <span class="kw">:authors</span> #{china}})
(<span class="kw">def</span><span class="fu"> wild-seed </span>{<span class="kw">:title</span> <span class="st">&quot;Wild Seed&quot;</span>, <span class="kw">:authors</span> #{octavia}})
(<span class="kw">def</span><span class="fu"> embassytown </span>{<span class="kw">:title</span> <span class="st">&quot;Embassytown&quot;</span>, <span class="kw">:authors</span> #{china}})
(<span class="kw">def</span><span class="fu"> little-schemer </span>{<span class="kw">:title</span> <span class="st">&quot;The Little Schemer&quot;</span>
                     <span class="kw">:authors</span> #{friedman, felleisen}})

(<span class="kw">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown, little-schemer])</code></pre>
<p>Now that the authors are in a set, it is easy to find out whether a book has some author or not.</p>
<section class="alert alert-success"><h3>
Exercise 23
</h3>
<p>Write the function <code>(has-author? book author)</code> that returns <code>true</code> if <code>author</code> is in the authors of <code>book</code> and otherwise <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(has-author? cities china)             <span class="co">;=&gt; true</span>
(has-author? cities felleisen)         <span class="co">;=&gt; false</span>
(has-author? little-schemer felleisen) <span class="co">;=&gt; true</span>
(has-author? little-schemer friedman)  <span class="co">;=&gt; true</span>
(has-author? little-schemer octavia)   <span class="co">;=&gt; false</span></code></pre>
</section>

<p>Does our previous definition for <code>all-author-names</code> still work? It does, but let’s take another look at it.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">defn</span><span class="fu"> all-author-names </span>[books]
  (<span class="kw">let</span> [author-names
         (<span class="kw">fn</span> [book] (<span class="kw">map</span> <span class="kw">:name</span> (<span class="kw">:authors</span> book)))]
    (<span class="kw">set</span> (<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-names books)))))</code></pre>
<p>Here we first turn each book into a sequence of names. Concatenate the sequences and finally turn this sequence into a set. Let’s break this into two steps. First, let’s define a function that returns all authors in a set. Then use this set to get the names.</p>
<p>For sets, there is a special function <code>(clojure.set/union set1 set2 ...)</code> that returns a new set that has all the elements of its parameters.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(clojure.set/union #{<span class="dv">1</span> <span class="dv">2</span>} #{<span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>} #{<span class="dv">7</span> <span class="dv">8</span>}) <span class="co">;=&gt; #{1 2 3 4 7 8}</span>
(<span class="kw">apply</span> clojure.set/union [#{<span class="dv">1</span> <span class="dv">2</span>} #{<span class="dv">5</span>} #{<span class="dv">7</span> <span class="dv">8</span>}])      <span class="co">;=&gt; #{1 2 5 7 8}</span></code></pre>
<p>That is, <code>union</code> works like <code>concat</code> but is specialized for sets. Let’s put this into good use:</p>
<section class="alert alert-success"><h3>
Exercise 24
</h3>
<p>Write the function <code>(authors books)</code> that returns the authors of every book in <code>books</code> as a set.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(authors [cities, wild-seed])              <span class="co">;=&gt; #{china, octavia}</span>
(authors [cities, wild-seed, embassytown]) <span class="co">;=&gt; #{china, octavia}</span>
(authors [little-schemer, cities])         <span class="co">;=&gt; #{china, friedman, felleisen}</span></code></pre>
</section>

<p>Now that we have all of our authors, defining <code>all-author-names</code> should be simple.</p>
<section class="alert alert-success"><h3>
Exercise 25
</h3>
<p>Write the function <code>(all-author-names books)</code> that works like the previous one and uses <code>authors</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(all-author-names books)
<span class="co">;=&gt; #{&quot;Matthias Felleisen&quot; &quot;China Miéville&quot;</span>
<span class="co">;     &quot;Octavia E. Butler&quot; &quot;Daniel Friedman&quot;}</span>
(all-author-names [cities, wild-seed])
<span class="co">;=&gt; #{&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;}</span>
(all-author-names []) <span class="co">;=&gt; #{}</span></code></pre>
</section>

<section id="string-representation-for-books" class="level3">
<h3>String Representation for Books</h3>
<p>Now that we have defined these books, I would like to have a readable string representation for them. Let’s start by defining a representation for a single author.</p>
<section class="alert alert-success"><h3>
Exercise 26
</h3>
<p>Write the function <code>(author-&gt;string author)</code> that returns a string representation of <code>author</code> as follows:</p>
<p>You can assume that every author with a <code>:death-year</code> also has a <code>:birth-year</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(author-&gt;string felleisen) <span class="co">;=&gt; &quot;Matthias Felleisen&quot;</span>
(author-&gt;string friedman)  <span class="co">;=&gt; &quot;Daniel Friedman (1944 - )&quot;</span>
(author-&gt;string octavia)   <span class="co">;=&gt; &quot;Octavia E. Butler (1947 - 2006)&quot;</span></code></pre>
Hint: you probably want to split this string into two parts: name and years. Use <code>let</code> to form these and use <code>str</code> to create the final string.
</section>

<p>Now we have a string representation for a single author. Some of our books had multiple authors, so we need to figure out a way to give a string representation for multiple authors. To do this, we need a handy helper function.</p>
<p>Sometimes you want to add something in between the elements of a sequence. For that, there is <code>(interpose separator a-seq)</code>, which returns a new sequence that has <code>separator</code> between each element of <code>a-seq</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">interpose</span> <span class="st">&quot;:&quot;</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])        <span class="co">;=&gt; (1 &quot;:&quot; 2 &quot;:&quot; 3)</span>
(<span class="kw">interpose</span> <span class="st">&quot; and &quot;</span> [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>]) <span class="co">;=&gt; (&quot;a&quot; &quot; and &quot; &quot;b&quot;)</span>
(<span class="kw">interpose</span> <span class="st">&quot;, &quot;</span> [])            <span class="co">;=&gt; ()</span>

(<span class="kw">apply</span> <span class="kw">str</span> (<span class="kw">interpose</span> <span class="st">&quot; and &quot;</span> [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>])) <span class="co">;=&gt; &quot;a and b&quot;</span></code></pre>
<p>With this, it shouldn’t be too hard to get a nice representation for a sequence of authors.</p>
<section class="alert alert-success"><h3>
Exercise 27
</h3>
<p>Write the function <code>(authors-&gt;string authors)</code> which takes a sequence of authors as a parameter and returns a string representation of <code>authors</code> in the following manner:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(authors-&gt;string (<span class="kw">:authors</span> little-schemer))
<span class="co">;=&gt; &quot;Daniel Friedman (1944 - ), Matthias Felleisen&quot;</span>
(authors-&gt;string #{octavia})          <span class="co">;=&gt; &quot;Octavia E. Butler (1947 - 2006)&quot;</span>
(authors-&gt;string #{})                 <span class="co">;=&gt; &quot;&quot;</span>
(authors-&gt;string #{octavia, friedman})
<span class="co">;=&gt; &quot;Octavia E. Butler (1947 - 2006), Daniel Friedman (1944 - )&quot;</span>
<span class="co">;   order doesn&#39;t matter</span></code></pre>
Since the authors are in a set, which doesn’t have a predefined order, the resulting string can have the authors in any order.
</section>

<p>Now that we can handle the case of multiple authors, we can move on to the string representation of a single book.</p>
<section class="alert alert-success"><h3>
Exercise 28
</h3>
<p>Write the function <code>(book-&gt;string book)</code> takes a single book as a parameter and returns a string representation of <code>book</code> as follows:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(book-&gt;string wild-seed) <span class="co">;=&gt; &quot;Wild Seed, written by Octavia E. Butler&quot;</span>
(book-&gt;string little-schemer)
<span class="co">;=&gt; &quot;The Little Schemer, written by Daniel Friedman (1944 - ), Matthias Felleisen&quot;</span>
<span class="co">;                                   ^-- order doesn&#39;t matter</span></code></pre>
Again, the order of authors in the string doesn’t matter.
</section>

<p>And finally, we can define a string representation for a sequence of books.</p>
<section class="alert alert-success"><h3>
Exercise 29
</h3>
<p>Write the function <code>(books-&gt;string books)</code> that takes a sequence of books as a parameter and returns a string representation of <code>books</code> like this:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(books-&gt;string []) <span class="co">;=&gt; &quot;No books.&quot;</span>
(books-&gt;string [cities])
<span class="co">;=&gt; &quot;1 book. The City and the City, written by China Miéville (1972 - ).&quot;</span>
(books-&gt;string [little-schemer, cities, wild-seed])
<span class="co">;=&gt; &quot;3 books. The Little Schemer, written by Daniel Friedman (1944 - ), Matthias Felleisen. The City and the City, written by China Miéville (1972 - ). Wild Seed, written by Octavia E. Butler (1947 - 2006).&quot;</span></code></pre>
</section>

</section>
</section>
<section id="filtering-sequences" class="level2">
<h2>Filtering sequences</h2>
<p>Another common function besides <code>map</code> is <code>filter</code>. It is used to select some elements of a sequence and disregard the rest:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">filter</span> <span class="kw">pos?</span> [-<span class="dv">4</span> <span class="dv">6</span> -<span class="dv">2</span> <span class="dv">7</span> -<span class="dv">8</span> <span class="dv">3</span>])
<span class="co">;=&gt;       (      6         7          3  )</span>
<span class="co">; value    -4    6    -2   7     -8   3</span>
<span class="co">; pos?   false true false true false true</span>

(<span class="kw">filter</span> (<span class="kw">fn</span> [x] (<span class="kw">&gt;</span> (<span class="kw">count</span> x) <span class="dv">2</span>)) [<span class="st">&quot;ff&quot;</span> <span class="st">&quot;f&quot;</span> <span class="st">&quot;ffffff&quot;</span> <span class="st">&quot;fff&quot;</span>])
<span class="co">;=&gt; (&quot;ffffff&quot; &quot;fff&quot;)</span></code></pre>
<p><code>(filter predicate collection)</code> takes two parameters, a function and a sequencable collection. It calls <code>predicate</code> (the function) on each element of <code>collection</code> and returns a sequence of elements of <code>collection</code> for which <code>predicate</code> returned a truthy value. In the above example the values <code>(6 7 3)</code> were selected because for them <code>pos?</code> returned <code>true</code>; for the others it returned <code>false</code>, a falsey value, and they were filtered out.</p>
<section class="alert alert-success"><h3>
Exercise 30
</h3>
<p>Write the function <code>(books-by-author author books)</code>.</p>
<p>Hint: <code>has-author?</code></p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(books-by-author china books)   <span class="co">;=&gt; (cities embassytown)</span>
(books-by-author octavia books) <span class="co">;=&gt; (wild-seed)</span></code></pre>
</section>

<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> authors </span>#{china, felleisen, octavia, friedman})</code></pre>
<section class="alert alert-success"><h3>
Exercise 31
</h3>
<p>Write the function <code>(author-by-name name authors)</code> that takes a string <code>name</code> and a sequence of authors and returns an author with the given name if one is found. If one is not found, then <code>nil</code> should be returned.</p>
<p>Hint: remember <code>first</code></p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(author-by-name <span class="st">&quot;Octavia E. Butler&quot;</span> authors)                <span class="co">;=&gt; octavia</span>
(author-by-name <span class="st">&quot;Octavia E. Butler&quot;</span> #{felleisen, friedman}) <span class="co">;=&gt; nil</span>
(author-by-name <span class="st">&quot;China Miéville&quot;</span> authors)                   <span class="co">;=&gt; china</span>
(author-by-name <span class="st">&quot;Goerge R. R. Martin&quot;</span> authors)              <span class="co">;=&gt; nil</span></code></pre>
</section>

<section class="alert alert-success"><h3>
Exercise 32
</h3>
<p>Write the function <code>(living-authors authors)</code> that takes a sequence of authors and returns those that are alive. Remember <code>alive?</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(living-authors authors)             <span class="co">;=&gt; (china, felleisen, friedman)</span>
(living-authors #{octavia})          <span class="co">;=&gt; ()</span>
(living-authors #{china, felleisen}) <span class="co">;=&gt; (china, felleisen)</span></code></pre>
The order in the results doesn’t matter.
</section>

<p>Here’s another book. This one has both living and dead authors, which is a useful test case for the following exercises.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> jrrtolkien </span>{<span class="kw">:name</span> <span class="st">&quot;J. R. R. Tolkien&quot;</span> <span class="kw">:birth-year</span> <span class="dv">1892</span> <span class="kw">:death-year</span> <span class="dv">1973</span>})
(<span class="kw">def</span><span class="fu"> christopher </span>{<span class="kw">:name</span> <span class="st">&quot;Christopher Tolkien&quot;</span> <span class="kw">:birth-year</span> <span class="dv">1924</span>})
(<span class="kw">def</span><span class="fu"> kay </span>{<span class="kw">:name</span> <span class="st">&quot;Guy Gavriel Kay&quot;</span> <span class="kw">:birth-year</span> <span class="dv">1954</span>})

(<span class="kw">def</span><span class="fu"> silmarillion </span>{<span class="kw">:title</span> <span class="st">&quot;Silmarillion&quot;</span>
                   <span class="kw">:authors</span> #{jrrtolkien, christopher, kay}})</code></pre>
<p>And here’s another with multiple dead authors:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> dick </span>{<span class="kw">:name</span> <span class="st">&quot;Philip K. Dick&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1928</span>, <span class="kw">:death-year</span> <span class="dv">1982</span>})
(<span class="kw">def</span><span class="fu"> zelazny </span>{<span class="kw">:name</span> <span class="st">&quot;Roger Zelazny&quot;</span>, <span class="kw">:birth-year</span> <span class="dv">1937</span>, <span class="kw">:death-year</span> <span class="dv">1995</span>})

(<span class="kw">def</span><span class="fu"> deus-irae </span>{<span class="kw">:title</span> <span class="st">&quot;Deus Irae&quot;</span>, <span class="kw">:authors</span> #{dick, zelazny}})</code></pre>
<p>If you want to know whether a collection is empty or not, you can use <code>(empty? coll)</code> to do that.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">empty?</span> [])  <span class="co">;=&gt; true</span>
(<span class="kw">empty?</span> #{}) <span class="co">;=&gt; true</span>
(<span class="kw">empty?</span> [<span class="dv">1</span>]) <span class="co">;=&gt; false</span></code></pre>
<section class="alert alert-success"><h3>
Exercise 33
</h3>
<p>Write the function <code>(has-a-living-author? book)</code> that returns <code>true</code> if <code>book</code> has a living author, and otherwise <code>false</code>.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(has-a-living-author? wild-seed)      <span class="co">;=&gt; false</span>
(has-a-living-author? silmarillion)   <span class="co">;=&gt; true</span>
(has-a-living-author? little-schemer) <span class="co">;=&gt; true</span>
(has-a-living-author? cities)         <span class="co">;=&gt; true</span>
(has-a-living-author? deus-irae)      <span class="co">;=&gt; false</span></code></pre>
</section>

<section class="alert alert-success"><h3>
Exercise 34
</h3>
<p>Write the function <code>(books-by-living-authors books)</code> that takes a sequence of books as a parameter and returns those that have a living author.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(books-by-living-authors books) <span class="co">;=&gt; (little-schemer cities embassytown)</span>
(books-by-living-authors (<span class="kw">concat</span> books [deus-irae, silmarillion]))
<span class="co">;=&gt; (little-schemer cities embassytown silmarillion)</span></code></pre>
</section>

<section id="keeping-your-vectors" class="level3">
<h3>Keeping your vectors</h3>
<p><code>map</code> and <code>filter</code> always return sequences, regardless of the collection type given as a parameter. Sometimes, however, you want the result to be a vector. For an example, you may want to index the vector afterwards. In this situation, you can use <code>mapv</code> and <code>filterv</code>, which are variants of <code>map</code> and <code>filter</code> that always return vectors.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(mapv ... [...])    <span class="co">;=&gt; [...]</span>
(filterv <span class="kw">pos?</span> [-<span class="dv">4</span> <span class="dv">6</span> -<span class="dv">2</span> <span class="dv">7</span> -<span class="dv">8</span> <span class="dv">3</span>])  <span class="co">;=&gt; [6 7 3]</span>
(filterv <span class="kw">pos?</span> #{-<span class="dv">4</span> <span class="dv">6</span> -<span class="dv">2</span> <span class="dv">7</span> -<span class="dv">8</span> <span class="dv">3</span>}) <span class="co">;=&gt; [3 6 7]</span>
(mapv ... #{...})   <span class="co">;=&gt; [...]</span></code></pre>
</section>
</section>
<section id="done" class="level2">
<h2>Done!</h2>
<p>Phew, that was quite a lot of stuff.</p>
<p><a href="style.html">Clojure with Style →</a></p>
</section>
<footer>
    <p>
        &copy; iloveponies

        <span style="float: right">
            <a href="mailto:juhana.laurinharju@cs.helsinki.fi">questions?</a>
        </span>
    </p>
</footer>
</div>
</div>
</body>
</html>
